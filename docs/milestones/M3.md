# M3 交付说明（proc）

## 范围

- `task_struct` 与 kernel thread 创建
- 可抢占调度框架（RR + 近似 CFS）
- x86_64 上下文切换汇编入口
- syscall 分发层与示例 syscall

## 后续扩展（M9 最小闭环）

- 增补 `pipe/dup2/read/close` 的 fd 语义（含每任务 fd 映射）
- 增补 `exit/waitpid` 子进程回收语义（ZOMBIE -> reap）
- 增补最小 `fork/exec`：
  - `fork` 复制当前任务元数据并返回子 pid
  - `exec(path)` 通过 VFS 校验路径存在，并在内置程序表中解析入口地址
  - 当前为“最小加载模型”，尚未实现 ELF 解析与用户态地址空间替换

## 后续扩展（M9 第二阶段）

- 将内置程序解析从 `syscall.c` 抽离为独立模块（`exec_registry`）
- `exec` 扩展为最小 `argv/envp` 语义：记录 `argc/envc`，并写入任务寄存器约定参数
- 保留兼容路径：旧调用可继续通过显式入口参数执行

## 后续扩展（M9 第三阶段）

- 将 `fd` 引用对象层从 `syscall.c` 抽离为独立模块（`kernel/proc/fd.c` + `include/nm/fd.h`）
- `dup2/fork/close` 改为统一 `fdobj` 引用计数语义，降低 syscall 层复杂度
- 通过模块化边界为后续 `O_CLOEXEC` 与 `exec` 关闭策略打基础

## 代码文件

- `include/nm/proc.h`
- `include/nm/syscall.h`
- `kernel/proc/task.c`
- `kernel/proc/sched.c`
- `kernel/proc/switch.S`
- `kernel/syscall/syscall.c`
- `tests/unit/test_sched.c`

## 关键函数签名

- `void proc_init(void);`
- `struct nm_task *task_create_kernel_thread(const char *name, void (*entry)(void *), void *arg);`
- `void sched_init(enum nm_sched_policy policy);`
- `struct nm_task *sched_pick_next(void);`
- `void sched_on_run(struct nm_task *task, uint64_t ticks);`
- `void nm_context_switch(uint64_t **old_rsp, uint64_t *new_rsp);`
- `int64_t syscall_dispatch(uint64_t nr, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4,`
  `uint64_t arg5, uint64_t arg6);`

## 验证命令

```bash
make clean all
make test
make smoke
```
